import os
import numpy as np
from math import sqrt, ceil
import cv2
import subprocess

# Dictionnaire global pour stocker le nombre de détections de chaque type de packer
packer_counts = {packer: 0 for packer in ['UPX', 'ASPack', 'PECompact', 'NSPack', 'FSG', 'RLPack', 'Morphine', 'ExeCryptor', 'Yoda', 'MEW']}

def identify_packer(file_path):
    try:
        # Exécute la commande PEiD en mode avancé pour identifier le packer
        result = subprocess.run(['peid', file_path], capture_output=True, text=True, check=True)

        # Liste des 10 packers les plus utilisés
        top_packers = ['UPX', 'ASPack', 'PECompact', 'NSPack', 'FSG', 'RLPack', 'Morphine', 'ExeCryptor', 'Yoda', 'MEW']

        # Vérifie si l'un des 10 packers est présent dans la sortie
        for packer in top_packers:
            if packer in result.stdout:
                print(f"{packer} Found!")
                return packer

    except subprocess.CalledProcessError as e:
        # En cas d'erreur, affiche le message d'erreur
        print(f"Erreur lors de l'identification du packer : {e.stderr} de chemin {file_path}")

    return None

def process_directory(directory_path, output_folder):
    # Crée un sous-dossier pour les images
    os.makedirs(output_folder, exist_ok=True)

    # Liste tous les fichiers du répertoire
    for filename in os.listdir(directory_path):
        # Vérifie si le fichier est de type exe
        if filename.endswith(".exe"):
            # Extrait le numéro du fichier exe (suppose que le numéro est le premier groupe de chiffres dans le nom de fichier)
            file_number = ''.join(filter(str.isdigit, filename))

            # Chemin complet du fichier
            input_file_path = os.path.join(directory_path, filename)

            # Lire le fichier binaire
            with open(input_file_path, 'rb') as binary_file:
                data = binary_file.read()

            # Data length in bytes
            data_len = len(data)

            # d is a vector of data_len bytes
            d = np.frombuffer(data, dtype=np.uint8)

            # Assume image shape should be close to square
            sqrt_len = int(ceil(sqrt(data_len)))  # Compute square root and round up

            # Required length in bytes.
            new_len = sqrt_len * sqrt_len

            # Number of bytes to pad (need to add zeros to the end of d)
            pad_len = new_len - data_len

            # Pad d with zeros at the end.
            padded_d = np.hstack((d, np.zeros(pad_len, np.uint8)))

            # Reshape 1D array into 2D array with sqrt_len pad_len x sqrt_len (im is going to be a Grayscale image).
            im = np.reshape(padded_d, (sqrt_len, sqrt_len))

            # Enregistre l'image dans le sous-dossier avec le numéro du fichier exe
            output_file_path = os.path.join(output_folder, f"{file_number}.png")
            cv2.imwrite(output_file_path, im)

            # Identifie le packer et met à jour le dictionnaire global des comptes
            packer_type = identify_packer(input_file_path)
            if packer_type is not None:
                packer_counts[packer_type] += 1

            print(f"Image enregistrée : {output_file_path}")

# Appel de la fonction pour chaque répertoire
process_directory('C:\\Users\\cocol\\Documents\\HEH2023\\MachineLearning\\Projet\\heh-cybersecurity-2023-2024\\trainset\\trainset\\safe', 'output_images_safe')
process_directory('C:\\Users\\cocol\\Documents\\HEH2023\\MachineLearning\\Projet\\heh-cybersecurity-2023-2024\\trainset\\trainset\\malware', 'output_images_malware')

# Affiche le tableau récapitulatif
print("Récapitulatif des détections de packer :")
for packer, count in packer_counts.items():
    print(f"{packer}: {count} fois")
